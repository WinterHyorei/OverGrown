<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multimedia Receiver â€” OverGrown</title>
<style>
  :root{
    --bg:#0b0a07;
    --panel:#14120f;
    --accent:#b86d2e; /* copper */
    --muted:#8b7a6b;
    --text:#e9e6e1;
    --glass: rgba(255,255,255,0.03);
    --shadow: rgba(0,0,0,0.6);
  }

  html,body{height:100%;margin:0;background:
    linear-gradient(180deg,#060504 0%, #0b0a07 40%, #0a0907 100%);
    font-family: "Courier New", monospace; color:var(--text);
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  .wrap{
    max-width:1100px;
    margin:28px auto;
    padding:20px;
  }

  /* Receiver container (retro panel) */
  .receiver {
    background: linear-gradient(180deg, #111 0%, #0f0e0c 100%);
    border-radius:10px;
    border:3px solid rgba(20,20,20,0.7);
    box-shadow: 0 12px 30px var(--shadow);
    display:grid;
    grid-template-columns: 1fr 360px;
    gap:18px;
    padding:18px;
    align-items:start;
  }

  /* Title strip */
  .title {
    grid-column:1 / -1;
    display:flex;
    justify-content:space-between;
    align-items:center;
    border-bottom:2px solid rgba(255,255,255,0.03);
    padding-bottom:8px;
    margin-bottom:6px;
  }
  .title h1{font-size:18px; margin:0; color:var(--accent); letter-spacing:1px;}
  .title .meta { font-size:12px; color:var(--muted); }

  /* Left: main receiver face */
  .face {
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  /* Frequency display (big) */
  .freq-panel {
    display:flex;
    gap:18px;
    align-items:center;
  }
  .freq-readout {
    background: linear-gradient(180deg,#0b0b09, #10100f);
    border:1px solid rgba(255,255,255,0.03);
    padding:14px 18px;
    min-width:220px;
    border-radius:6px;
    box-shadow: inset 0 -6px 18px rgba(0,0,0,0.45);
  }
  .freq-readout .freq {
    font-size:28px;
    letter-spacing:1px;
    color:#ffdca8;
  }
  .freq-readout .label {
    font-size:11px;
    color:var(--muted);
    margin-top:4px;
  }

  /* Response feed */
  .feed {
    flex:1;
    background:var(--glass);
    border:1px solid rgba(255,255,255,0.02);
    padding:12px;
    min-height:160px;
    max-height:320px; /* keeps layout stable */
    overflow-y:auto;
    border-radius:6px;
    box-shadow: inset 0 6px 14px rgba(0,0,0,0.45);
    font-size:13px;
    line-height:1.35;
    white-space:pre-wrap;
  }

  /* image column on the right */
  .right {
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  .portrait {
    background: linear-gradient(180deg,#090806,#11100f);
    border:1px solid rgba(255,255,255,0.02);
    height:320px;
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    position:relative;
  }
  .portrait img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
    transform: scale(1);
    transition: transform .35s ease, opacity .35s ease;
    opacity:0;
  }
  .portrait .placeholder {
    color:var(--muted);
    font-size:14px;
  }

  /* controls: prev / test / next horizontally */
  .controls {
    display:flex;
    gap:10px;
    align-items:center;
  }
  .btn {
    background:linear-gradient(180deg,#2b2a28,#161513);
    border:2px solid rgba(255,255,255,0.03);
    padding:10px 14px;
    border-radius:6px;
    min-width:88px;
    cursor:pointer;
    color:var(--text);
    box-shadow: 0 6px 12px rgba(0,0,0,0.5);
    text-align:center;
    font-weight:700;
    letter-spacing:0.6px;
  }
  .btn.small { min-width:68px; padding:8px 10px; font-size:13px; }
  .btn:active { transform: translateY(1px); }

  /* footer row with exit */
  .footer {
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin-top:6px;
  }

  /* analog styling: tuner wheel */
  .tuner {
    display:flex;
    align-items:center;
    gap:12px;
  }
  .tuner .knob {
    width:54px;height:54px;border-radius:50%;
    background:conic-gradient(from 150deg,#2b2a28,#1a1918);
    border:4px solid rgba(0,0,0,0.6);
    box-shadow: inset 0 -8px 14px rgba(0,0,0,0.6), 0 8px 24px rgba(0,0,0,0.6);
    display:flex;align-items:center;justify-content:center;color:var(--muted);
    font-weight:700;
  }
  .tuner .led {
    height:10px;width:40px;border-radius:4px;background:linear-gradient(90deg,#2b2a28,#0f0e0c);
    display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:11px;
    border:1px solid rgba(255,255,255,0.02)
  }

  /* small details */
  .smallprint { font-size:12px;color:var(--muted); }

  /* responsive */
  @media (max-width:920px){
    .receiver{grid-template-columns:1fr; padding:12px;}
    .right{order:-1}
    .portrait{height:220px}
  }
  
  @media (max-width: 600px) {
  .receiver {
    grid-template-columns: 1fr;
    padding: 12px;
  }
  .right {
    order: -1; /* move portrait above main panel */
  }
  .portrait {
    height: 180px; /* smaller for phones */
  }
  .btn {
    padding: 12px 16px;
    min-width: 100%;
    font-size: 15px;
  }
  .freq-readout .freq {
    font-size: 22px;
  }
  .feed {
    font-size: 12px;
    min-height: 120px;
    max-height: 240px;
  }
  .tuner .knob {
    width: 44px;
    height: 44px;
  }
}

</style>
</head>
<body style="
  background: url('receiver.jfif') no-repeat center center fixed;
  background-size: cover;
">
  <div class="wrap">
    <div class="receiver" role="application" aria-label="Multimedia Receiver">
      <div class="title">
        <h1>MULTIMEDIA RECEIVER â€” OverGrown</h1>
        <div class="meta">v1.0 â€” Channel 01 ready</div>
      </div>

      <!-- Left side -->
      <div class="face">
        <div class="freq-panel">
          <div class="freq-readout" aria-live="polite">
            <div class="freq" id="frequencyLabel">88.7 FM</div>
            <div class="label smallprint">CH <span id="channelLabel">01</span></div>
          </div>

          <div class="tuner" style="margin-left:auto;">
            <div class="knob">TUNE</div>
            <div class="led" id="signalState">â—† SIGNAL</div>
          </div>
        </div>

        <div id="feed" class="feed" aria-live="polite" role="log">
          <!-- dynamic text appears here -->
        </div>

        <div class="controls" aria-hidden="false">
          <button id="prevBtn" class="btn small">PREV</button>
          <button id="testBtn" class="btn">TEST</button>
          <button id="nextBtn" class="btn small">NEXT</button>
        </div>

        <div class="footer">
          <div class="smallprint">Tip: press TEST to re-scan current channel.</div>
          <div>
            <button id="exitBtn" class="btn small">EXIT</button>
          </div>
        </div>
      </div>

      <!-- Right column -->
      <div class="right">
        <div class="portrait" id="portraitBox" aria-hidden="false">
          <div class="placeholder">No signal  </div>
          <img id="portraitImg" alt="Personality portrait">
        </div>

        <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
          <div class="smallprint">CHANNEL POOL: 5</div>
          <div class="smallprint" id="lastRoll">â€”</div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  Multimedia Receiver JS
  - channelIndex 0 is Channel 01 (lowest number) and loads on open
  - replace placeholder image filenames with your actual image files when ready
*/

const channels = [
  { id: "01", freq: "88.3", label: "88.3 FM" }, // Channel 01 (lowest)
  { id: "02", freq: "94.1", label: "94.1 FM" },
  { id: "03", freq: "99.5", label: "99.5 FM" },
  { id: "04", freq: "103.2", label: "103.2 FM" },
  { id: "05", freq: "107.7", label: "107.7 FM" }
];

// Transmission timing control
let isScanning = false; // prevents spam during scan
const responseDelayMin = 3000; // 3 seconds
const responseDelayMax = 8000; // 8 seconds

// Personality pool (shared). Images are placeholders you can swap later.
const personalities = {
  "Abby": {
    img: "p_abby.png",
    lines: [
      "â€¦If you're out there: don't go to the marsh. Promise me.",
      "Found a tin with someone's name. We keep it in the shed.",
      "They used to sing here before the walls came downâ€¦"
    ]
  },
  "Silas": {
    img: "p_silas.png",
    lines: [
      "Coordinates checked: no friendly signatures nearby.",
      "There was something in the ruins. It blinked with my torchlight.",
      "Don't reply to the frequency if you hear the third tone."
    ]
  },
  "Raven": {
    img: "p_raven.png",
    lines: [
      "Smuggled seeds for trade. Interested?",
      "The market's quiet. Too quiet for my taste.",
      "If we meet, bring coffee. Black. No sugar."
    ]
  }
};

// Static/unknown responses (higher weight => more likely)
const staticPool = [
  "[STATIC]",
  "â€”...zzchhhâ€”â€”",
  "[DEAD AIR]",
  "................",
  "Faint voice: 'â€¦hello? is anyoneâ€”'",
  "Faint voice: 'â€¦a-anyone, please we need heâ€”'",
  "[SIGNAL INTERRUPTION]",
  "",
  "",
  "",
  ""
];

// Each channel gets a local pool referencing personalities and static weights.
// Adjust weights to control chance of hearing a "real" personality vs static.
const channelPools = [
  // channel 01: slightly higher chance of real transmissions
  { personalities: ["Abby","Silas"], realWeight: 0.09 }, // 45% personality, 55% static
  { personalities: ["Raven"], realWeight: 0.08 },
  { personalities: ["Silas","Raven"], realWeight: 0.18 },
  { personalities: ["Abby"], realWeight: 0.04 },
  { personalities: [], realWeight: 0.10 } // mostly static
];

let channelIndex = 0; // starts at Channel 01 (lowest)
const frequencyLabel = document.getElementById('frequencyLabel');
const channelLabel = document.getElementById('channelLabel');
const feed = document.getElementById('feed');
const portraitBox = document.getElementById('portraitBox');
const portraitImg = document.getElementById('portraitImg');
const lastRoll = document.getElementById('lastRoll');
const signalState = document.getElementById('signalState');

function setChannel(idx){
  channelIndex = (idx + channels.length) % channels.length;
  const ch = channels[channelIndex];
  frequencyLabel.textContent = ch.label;
  channelLabel.textContent = ch.id;
  // clear portrait placeholder but keep previous feed
  portraitImg.style.opacity = 0;
  setTimeout(()=> {
    portraitImg.src = "";
    portraitImg.alt = "";
    portraitBox.querySelector('.placeholder').style.display = 'block';
  }, 250);
  appendToFeed(`> TUNED TO ${ch.label} â€” SCANNING...`);
  // small visual indicator
  signalState.textContent = "â—† SCANNING";
  setTimeout(()=> signalState.textContent = "â—† SIGNAL", 600);
  // auto-run a first test for the channel so Channel 01 works on load
  setTimeout(()=> performTest(), 350);
}

function appendToFeed(text){
  const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  feed.textContent += `\n[${time}] ${text}`;
  feed.scrollTop = feed.scrollHeight;
}

// weighted roll: returns {type: "personality"|"static", name, text}
function rollChannelOutput(idx){
  const pool = channelPools[idx];
  const roll = Math.random();
  const usePersonality = (roll < pool.realWeight) && pool.personalities.length > 0;
  if (usePersonality){
    // pick random personality from that channel's allowed list
    const candidateName = pool.personalities[Math.floor(Math.random() * pool.personalities.length)];
    const persona = personalities[candidateName];
    const text = persona.lines[Math.floor(Math.random() * persona.lines.length)];
    return { type: "personality", name: candidateName, text };
  } else {
    // static / unknown - pick random static
    const text = staticPool[Math.floor(Math.random() * staticPool.length)];
    return { type: "static", name: null, text };
  }
}
// ===============================
// Sound & Music Event System
// ===============================
const staticSound = new Audio("static.wav");
staticSound.volume = 0.4;

const musicEvents = [
  { name: "Outlands Signal", src: "audio/outlands_signal.mp3" },
  { name: "Hyorei Pulse", src: "audio/hyorei_pulse.mp3" },
  { name: "Unknown Source", src: "audio/unknown_signal.mp3" }
];

// Roll chances
const musicChance = 0.005; // 1.5% chance to play rare music event

// Handles playback logic for channel test
function playChannelAudio(result){
  // Always start static first
  staticSound.currentTime = 0;
  staticSound.play();

  // If we rolled a personality or event, fade static out
  if (result.type === "personality"){
    setTimeout(() => staticSound.pause(), 600);
  }

  // Low chance for random music event
  if (Math.random() < musicChance){
    setTimeout(() => {
      staticSound.pause();
      const event = musicEvents[Math.floor(Math.random() * musicEvents.length)];
      const audio = new Audio(event.src);
      audio.volume = 0.5;
      audio.play();
      appendToFeed(`ðŸŽµ Receiving: ${event.name}...`);
    }, 800);
  }
}

function renderOutput(result){
  lastRoll.textContent = `rolled: ${result.type.toUpperCase()}${result.name ? " â€” " + result.name : ""}`;
  if (result.type === "personality"){
    // show portrait
    portraitImg.src = personalities[result.name].img;
    portraitImg.alt = result.name;
    portraitBox.querySelector('.placeholder').style.display = 'none';
    // fade portrait in
    portraitImg.style.opacity = 0;
    setTimeout(()=> portraitImg.style.opacity = 1, 40);
    appendToFeed(`${result.name}: "${result.text}"`);
  } else {
    // static - hide portrait
    portraitImg.style.opacity = 0;
    setTimeout(()=> {
      portraitImg.src = "";
      portraitImg.alt = "";
      portraitBox.querySelector('.placeholder').style.display = 'block';
    }, 300);
    appendToFeed(result.text);
  }
}

function performTest(){
  if (isScanning) {
    appendToFeed("> Receiver busy... awaiting signal.");
    return; // prevent spam
  }

  isScanning = true;
  const waitTime = Math.floor(Math.random() * (responseDelayMax - responseDelayMin + 1)) + responseDelayMin;
  
  appendToFeed("> Scanning frequencies...");
  signalState.textContent = "â—† SCANNING";
  
  // Play static while waiting
  staticSound.currentTime = 0;
  staticSound.play();

  setTimeout(() => {
    const result = rollChannelOutput(channelIndex);
    staticSound.pause();
    playChannelAudio(result);
    renderOutput(result);
    signalState.textContent = "â—† SIGNAL LOCKED";
    isScanning = false;
  }, waitTime);
}

// control handlers
document.getElementById('prevBtn').addEventListener('click', ()=> {
  setChannel(channelIndex - 1);
});
document.getElementById('nextBtn').addEventListener('click', ()=> {
  setChannel(channelIndex + 1);
});
document.getElementById('testBtn').addEventListener('click', ()=> {
  performTest();
});
document.getElementById("exitBtn").addEventListener("click", () => {
window.location.href = "RandomAccessTerminal.html";
});

// initialize channel 01 on load
setChannel(0);

/* Accessibility: allow keyboard arrows for prev/next and space for test */
window.addEventListener('keydown', (e) => {
  if (e.key === "ArrowLeft") { setChannel(channelIndex - 1); }
  if (e.key === "ArrowRight") { setChannel(channelIndex + 1); }
  if (e.key === " ") { e.preventDefault(); performTest(); }
});

/* NOTE:
 - Replace 'p_abby.png', 'p_silas.png', etc with actual files in the same folder.
 - You can tweak channelPools[].realWeight to change likelihood of personalities.
 - To persist continuity: use a map from personality name -> lastSeen to prefer showing same portrait across channels.
*/
</script>
</body>
</html>
